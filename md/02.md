# LOVE4DETAILING REBUILD: PHASE 2 IMPLEMENTATION GUIDE
## Core API & Services (Days 2-3)

---

## Overview

Phase 2 builds the core API layer and service architecture that powers the entire Love4Detailing application. This phase establishes the standardized API patterns, authentication system, and business logic services that all features will depend on.

**Critical Success Factor:** Every API endpoint must follow the exact standardized response format. No exceptions. This consistency is what enables reliable frontend development and smooth integration.

---

## PRE-PHASE VALIDATION

Before starting Phase 2, confirm Phase 1 completion:

```bash
# Verify TypeScript compilation
npx tsc --noEmit
# Should complete with zero errors

# Verify database health
curl http://localhost:3000/api/health
# Should return {"success": true, "data": {...}}

# Verify build system
npm run build
# Should complete successfully
```

**All three commands must pass before proceeding.**

---

## STEP 1: STANDARDIZED API LAYER FOUNDATION (45 minutes)

### 1.1 API Response Handler Utilities

**Create: `src/lib/api/response.ts`**

```typescript
import { NextResponse } from 'next/server'

export interface ApiResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    message: string
    code?: string
    details?: any
  }
  metadata?: {
    pagination?: {
      page: number
      limit: number
      total: number
      totalPages: number
    }
    timestamp?: string
    version?: string
  }
}

export class ApiResponseHandler {
  static success<T>(data?: T, metadata?: ApiResponse<T>['metadata']): NextResponse<ApiResponse<T>> {
    return NextResponse.json({
      success: true,
      data,
      metadata: {
        timestamp: new Date().toISOString(),
        ...metadata,
      },
    })
  }

  static error(
    message: string,
    code?: string,
    status: number = 400,
    details?: any
  ): NextResponse<ApiResponse> {
    return NextResponse.json({
      success: false,
      error: {
        message,
        code,
        details,
      },
      metadata: {
        timestamp: new Date().toISOString(),
      },
    }, { status })
  }

  static validationError(message: string, details?: any): NextResponse<ApiResponse> {
    return this.error(message, 'VALIDATION_ERROR', 400, details)
  }

  static unauthorized(message: string = 'Unauthorized'): NextResponse<ApiResponse> {
    return this.error(message, 'UNAUTHORIZED', 401)
  }

  static forbidden(message: string = 'Forbidden'): NextResponse<ApiResponse> {
    return this.error(message, 'FORBIDDEN', 403)
  }

  static notFound(message: string = 'Resource not found'): NextResponse<ApiResponse> {
    return this.error(message, 'NOT_FOUND', 404)
  }

  static serverError(message: string = 'Internal server error'): NextResponse<ApiResponse> {
    return this.error(message, 'INTERNAL_ERROR', 500)
  }

  static paginated<T>(
    data: T[],
    page: number,
    limit: number,
    total: number
  ): NextResponse<ApiResponse<T[]>> {
    const totalPages = Math.ceil(total / limit)
    
    return NextResponse.json({
      success: true,
      data,
      metadata: {
        pagination: {
          page,
          limit,
          total,
          totalPages,
        },
        timestamp: new Date().toISOString(),
      },
    })
  }
}
```

### 1.2 API Validation Middleware

**Create: `src/lib/api/validation.ts`**

```typescript
import { NextRequest } from 'next/server'
import { z, ZodSchema } from 'zod'
import { ApiResponseHandler } from './response'

export class ApiValidator {
  static async validateBody<T>(
    request: NextRequest,
    schema: ZodSchema<T>
  ): Promise<{ data: T; error: null } | { data: null; error: Response }> {
    try {
      const body = await request.json()
      const result = schema.safeParse(body)
      
      if (!result.success) {
        return {
          data: null,
          error: ApiResponseHandler.validationError(
            'Request validation failed',
            result.error.flatten()
          )
        }
      }
      
      return { data: result.data, error: null }
    } catch (error) {
      return {
        data: null,
        error: ApiResponseHandler.validationError('Invalid JSON in request body')
      }
    }
  }

  static validateQuery<T>(
    request: NextRequest,
    schema: ZodSchema<T>
  ): { data: T; error: null } | { data: null; error: Response } {
    try {
      const { searchParams } = new URL(request.url)
      const queryObject: Record<string, string> = {}
      
      searchParams.forEach((value, key) => {
        queryObject[key] = value
      })
      
      const result = schema.safeParse(queryObject)
      
      if (!result.success) {
        return {
          data: null,
          error: ApiResponseHandler.validationError(
            'Query parameter validation failed',
            result.error.flatten()
          )
        }
      }
      
      return { data: result.data, error: null }
    } catch (error) {
      return {
        data: null,
        error: ApiResponseHandler.validationError('Invalid query parameters')
      }
    }
  }

  static validateParams<T>(
    params: Record<string, string | string[]>,
    schema: ZodSchema<T>
  ): { data: T; error: null } | { data: null; error: Response } {
    const result = schema.safeParse(params)
    
    if (!result.success) {
      return {
        data: null,
        error: ApiResponseHandler.validationError(
          'URL parameter validation failed',
          result.error.flatten()
        )
      }
    }
    
    return { data: result.data, error: null }
  }
}
```

### 1.3 Authentication Utilities

**Create: `src/lib/api/auth.ts`**

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { ApiResponseHandler } from './response'
import { UserProfile } from '@/lib/utils/database'

export interface AuthenticatedRequest {
  user: {
    id: string
    email: string
    role: string
  }
  profile: UserProfile
}

export class ApiAuth {
  static async authenticate(
    request: NextRequest
  ): Promise<{ auth: AuthenticatedRequest; error: null } | { auth: null; error: Response }> {
    try {
      const supabase = createClient()
      
      // Get user from session
      const { data: { user }, error: userError } = await supabase.auth.getUser()
      
      if (userError || !user) {
        return {
          auth: null,
          error: ApiResponseHandler.unauthorized('Authentication required')
        }
      }

      // Get user profile
      const { data: profile, error: profileError } = await supabase
        .from('user_profiles')
        .select('*')
        .eq('id', user.id)
        .single()

      if (profileError || !profile) {
        return {
          auth: null,
          error: ApiResponseHandler.unauthorized('User profile not found')
        }
      }

      return {
        auth: {
          user: {
            id: user.id,
            email: user.email!,
            role: profile.role,
          },
          profile,
        },
        error: null,
      }
    } catch (error) {
      console.error('Authentication error:', error)
      return {
        auth: null,
        error: ApiResponseHandler.serverError('Authentication failed')
      }
    }
  }

  static async requireRole(
    request: NextRequest,
    allowedRoles: string[]
  ): Promise<{ auth: AuthenticatedRequest; error: null } | { auth: null; error: Response }> {
    const { auth, error } = await this.authenticate(request)
    
    if (error) {
      return { auth: null, error }
    }

    if (!allowedRoles.includes(auth!.user.role)) {
      return {
        auth: null,
        error: ApiResponseHandler.forbidden(`Access denied. Required roles: ${allowedRoles.join(', ')}`)
      }
    }

    return { auth, error: null }
  }

  static async requireAdmin(
    request: NextRequest
  ): Promise<{ auth: AuthenticatedRequest; error: null } | { auth: null; error: Response }> {
    return this.requireRole(request, ['admin', 'super_admin'])
  }

  static async requireCustomer(
    request: NextRequest
  ): Promise<{ auth: AuthenticatedRequest; error: null } | { auth: null; error: Response }> {
    return this.requireRole(request, ['customer', 'admin', 'super_admin'])
  }
}
```

---

## STEP 2: AUTHENTICATION SYSTEM IMPLEMENTATION (60 minutes)

### 2.1 Authentication API Routes

**Create: `src/app/api/auth/register/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { ApiValidator } from '@/lib/api/validation'
import { z } from 'zod'

const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  firstName: z.string().min(1, 'First name is required').max(100),
  lastName: z.string().min(1, 'Last name is required').max(100),
  phone: z.string().optional(),
})

export async function POST(request: NextRequest) {
  try {
    // Validate request body
    const { data: body, error: validationError } = await ApiValidator.validateBody(
      request,
      registerSchema
    )

    if (validationError) {
      return validationError
    }

    const supabase = createClient()

    // Create auth user
    const { data: authData, error: authError } = await supabase.auth.signUp({
      email: body.email,
      password: body.password,
      options: {
        data: {
          first_name: body.firstName,
          last_name: body.lastName,
          phone: body.phone,
        },
      },
    })

    if (authError) {
      if (authError.message.includes('already registered')) {
        return ApiResponseHandler.error(
          'An account with this email already exists',
          'EMAIL_ALREADY_EXISTS',
          409
        )
      }
      
      return ApiResponseHandler.error(
        'Registration failed',
        'REGISTRATION_FAILED',
        400,
        authError.message
      )
    }

    if (!authData.user) {
      return ApiResponseHandler.serverError('User creation failed')
    }

    // Create user profile
    const { data: profile, error: profileError } = await supabase
      .from('user_profiles')
      .insert({
        id: authData.user.id,
        email: body.email,
        first_name: body.firstName,
        last_name: body.lastName,
        phone: body.phone,
        role: 'customer',
      })
      .select()
      .single()

    if (profileError) {
      console.error('Profile creation error:', profileError)
      // Note: User was created in auth, but profile failed
      // In production, you might want to handle this with a cleanup process
    }

    return ApiResponseHandler.success({
      user: {
        id: authData.user.id,
        email: authData.user.email,
      },
      requiresEmailConfirmation: !authData.session,
      message: authData.session 
        ? 'Registration successful' 
        : 'Registration successful. Please check your email to confirm your account.',
    })

  } catch (error) {
    console.error('Registration error:', error)
    return ApiResponseHandler.serverError('Registration failed')
  }
}
```

**Create: `src/app/api/auth/login/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { ApiValidator } from '@/lib/api/validation'
import { z } from 'zod'

const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
})

export async function POST(request: NextRequest) {
  try {
    // Validate request body
    const { data: body, error: validationError } = await ApiValidator.validateBody(
      request,
      loginSchema
    )

    if (validationError) {
      return validationError
    }

    const supabase = createClient()

    // Authenticate user
    const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
      email: body.email,
      password: body.password,
    })

    if (authError) {
      return ApiResponseHandler.unauthorized('Invalid email or password')
    }

    if (!authData.user || !authData.session) {
      return ApiResponseHandler.serverError('Authentication failed')
    }

    // Get user profile
    const { data: profile, error: profileError } = await supabase
      .from('user_profiles')
      .select('*')
      .eq('id', authData.user.id)
      .single()

    if (profileError || !profile) {
      return ApiResponseHandler.serverError('User profile not found')
    }

    // Check if user is active
    if (!profile.is_active) {
      return ApiResponseHandler.forbidden('Account is deactivated')
    }

    return ApiResponseHandler.success({
      user: {
        id: authData.user.id,
        email: authData.user.email,
        firstName: profile.first_name,
        lastName: profile.last_name,
        role: profile.role,
      },
      session: {
        accessToken: authData.session.access_token,
        refreshToken: authData.session.refresh_token,
        expiresAt: authData.session.expires_at,
      },
    })

  } catch (error) {
    console.error('Login error:', error)
    return ApiResponseHandler.serverError('Login failed')
  }
}
```

**Create: `src/app/api/auth/logout/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { ApiResponseHandler } from '@/lib/api/response'

export async function POST(request: NextRequest) {
  try {
    const supabase = createClient()

    const { error } = await supabase.auth.signOut()

    if (error) {
      console.error('Logout error:', error)
      return ApiResponseHandler.error('Logout failed', 'LOGOUT_FAILED', 400)
    }

    return ApiResponseHandler.success({
      message: 'Successfully logged out',
    })

  } catch (error) {
    console.error('Logout error:', error)
    return ApiResponseHandler.serverError('Logout failed')
  }
}
```

**Create: `src/app/api/auth/me/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { ApiAuth } from '@/lib/api/auth'
import { ApiResponseHandler } from '@/lib/api/response'

export async function GET(request: NextRequest) {
  try {
    const { auth, error } = await ApiAuth.authenticate(request)

    if (error) {
      return error
    }

    return ApiResponseHandler.success({
      user: {
        id: auth!.profile.id,
        email: auth!.profile.email,
        firstName: auth!.profile.first_name,
        lastName: auth!.profile.last_name,
        phone: auth!.profile.phone,
        role: auth!.profile.role,
        isActive: auth!.profile.is_active,
        createdAt: auth!.profile.created_at,
      },
    })

  } catch (error) {
    console.error('Get user error:', error)
    return ApiResponseHandler.serverError('Failed to get user information')
  }
}
```

### 2.2 Admin User Creation Script

**Create: `src/lib/scripts/create-admin-users.ts`**

```typescript
import { createClient } from '@supabase/supabase-js'
import { env } from '@/lib/config/environment'

// This script creates the initial admin users
// Run with: npm run create-admins

const supabase = createClient(
  env.supabase.url,
  env.supabase.serviceRoleKey!, // Service role key bypasses RLS
  {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
    },
  }
)

interface AdminUser {
  email: string
  password: string
  firstName: string
  lastName: string
  role: 'admin' | 'super_admin'
}

const adminUsers: AdminUser[] = [
  {
    email: 'zell@love4detailing.com',
    password: 'TempPass123!', // Client should change this immediately
    firstName: 'Zell',
    lastName: 'Love4Detailing',
    role: 'admin',
  },
  {
    email: 'paul@evans-studio.co.uk',
    password: 'DevPass123!', // You should change this immediately
    firstName: 'Paul',
    lastName: 'Evans',
    role: 'super_admin',
  },
]

async function createAdminUser(user: AdminUser) {
  try {
    console.log(`Creating admin user: ${user.email}`)

    // Create auth user
    const { data: authData, error: authError } = await supabase.auth.admin.createUser({
      email: user.email,
      password: user.password,
      email_confirm: true, // Skip email confirmation for admin users
      user_metadata: {
        first_name: user.firstName,
        last_name: user.lastName,
        role: user.role,
      },
    })

    if (authError) {
      if (authError.message.includes('already registered')) {
        console.log(`‚ùå User ${user.email} already exists`)
        return false
      }
      throw authError
    }

    if (!authData.user) {
      throw new Error('User creation failed - no user returned')
    }

    // Create user profile
    const { error: profileError } = await supabase
      .from('user_profiles')
      .insert({
        id: authData.user.id,
        email: user.email,
        first_name: user.firstName,
        last_name: user.lastName,
        role: user.role,
        is_active: true,
      })

    if (profileError) {
      console.error(`Profile creation failed for ${user.email}:`, profileError)
      // Clean up auth user if profile creation fails
      await supabase.auth.admin.deleteUser(authData.user.id)
      throw profileError
    }

    console.log(`‚úÖ Successfully created ${user.role}: ${user.email}`)
    return true

  } catch (error) {
    console.error(`‚ùå Failed to create user ${user.email}:`, error)
    return false
  }
}

export async function createAllAdminUsers() {
  console.log('üöÄ Creating admin users...')
  
  let successCount = 0
  let failCount = 0

  for (const user of adminUsers) {
    const success = await createAdminUser(user)
    if (success) {
      successCount++
    } else {
      failCount++
    }
  }

  console.log('\nüìä Summary:')
  console.log(`‚úÖ Successfully created: ${successCount} users`)
  console.log(`‚ùå Failed: ${failCount} users`)

  if (successCount > 0) {
    console.log('\nüîê Important Security Notes:')
    console.log('1. Admin users should change their passwords immediately after first login')
    console.log('2. Use strong, unique passwords for all admin accounts')
    console.log('3. Enable MFA if available in your authentication system')
    console.log('\nüìß Admin Login Credentials:')
    adminUsers.forEach(user => {
      console.log(`${user.role}: ${user.email} / ${user.password}`)
    })
    console.log('\n‚ö†Ô∏è  Store these credentials securely and delete them from logs!')
  }

  return { successCount, failCount }
}

// Allow running directly with node
if (require.main === module) {
  createAllAdminUsers()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error('Script failed:', error)
      process.exit(1)
    })
}
```

**Add script to package.json:**

**Update: `package.json`** (add to scripts section)

```json
{
  "scripts": {
    "create-admins": "tsx src/lib/scripts/create-admin-users.ts",
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  }
}
```

**Install tsx for script execution:**

```bash
npm install -D tsx
```

---

## STEP 3: SERVICES LAYER ARCHITECTURE (75 minutes)

### 3.1 Service Base Class

**Create: `src/lib/services/base.ts`**

```typescript
import { createClient } from '@/lib/supabase/server'
import { ApiResponseHandler } from '@/lib/api/response'

export interface ServiceResponse<T = any> {
  success: boolean
  data?: T
  error?: {
    message: string
    code?: string
    details?: any
  }
}

export abstract class BaseService {
  protected supabase = createClient()

  protected handleSuccess<T>(data?: T): ServiceResponse<T> {
    return {
      success: true,
      data,
    }
  }

  protected handleError(
    message: string,
    code?: string,
    details?: any
  ): ServiceResponse {
    return {
      success: false,
      error: {
        message,
        code,
        details,
      },
    }
  }

  protected async executeQuery<T>(
    queryFn: () => Promise<{ data: T | null; error: any }>,
    errorMessage: string = 'Database operation failed'
  ): Promise<ServiceResponse<T>> {
    try {
      const { data, error } = await queryFn()

      if (error) {
        console.error('Database error:', error)
        return this.handleError(errorMessage, 'DATABASE_ERROR', error)
      }

      return this.handleSuccess(data)
    } catch (error) {
      console.error('Service error:', error)
      return this.handleError(errorMessage, 'SERVICE_ERROR', error)
    }
  }
}
```

### 3.2 Services API Management

**Create: `src/lib/services/services.ts`**

```typescript
import { BaseService } from './base'
import { ServiceWithCategory, Service, ServiceCategory, VehicleSize } from '@/lib/utils/database'

export interface ServiceFilters {
  categoryId?: string
  search?: string
  isActive?: boolean
}

export interface ServiceWithPricing extends ServiceWithCategory {
  priceRange: {
    min: number
    max: number
  }
  category: ServiceCategory
}

export class ServicesService extends BaseService {
  
  async getAllServices(filters: ServiceFilters = {}): Promise<ServiceResponse<ServiceWithPricing[]>> {
    return this.executeQuery(async () => {
      let query = this.supabase
        .from('services')
        .select(`
          *,
          category:service_categories(*)
        `)
        .order('display_order')

      // Apply filters
      if (filters.categoryId) {
        query = query.eq('category_id', filters.categoryId)
      }

      if (filters.search) {
        query = query.or(`name.ilike.%${filters.search}%,short_description.ilike.%${filters.search}%`)
      }

      if (filters.isActive !== undefined) {
        query = query.eq('is_active', filters.isActive)
      }

      const { data: services, error } = await query

      if (error) return { data: null, error }

      // Get vehicle sizes for price calculation
      const { data: vehicleSizes, error: sizesError } = await this.supabase
        .from('vehicle_sizes')
        .select('*')
        .eq('is_active', true)
        .order('price_multiplier')

      if (sizesError) return { data: null, error: sizesError }

      // Calculate price ranges for each service
      const servicesWithPricing: ServiceWithPricing[] = services.map(service => {
        const minMultiplier = vehicleSizes[0]?.price_multiplier || 1
        const maxMultiplier = vehicleSizes[vehicleSizes.length - 1]?.price_multiplier || 1

        return {
          ...service,
          priceRange: {
            min: Math.round(service.base_price * minMultiplier),
            max: Math.round(service.base_price * maxMultiplier),
          },
        }
      })

      return { data: servicesWithPricing, error: null }
    }, 'Failed to fetch services')
  }

  async getServiceById(id: string): Promise<ServiceResponse<ServiceWithPricing>> {
    return this.executeQuery(async () => {
      const { data: service, error } = await this.supabase
        .from('services')
        .select(`
          *,
          category:service_categories(*)
        `)
        .eq('id', id)
        .eq('is_active', true)
        .single()

      if (error) return { data: null, error }

      // Get vehicle sizes for price calculation
      const { data: vehicleSizes, error: sizesError } = await this.supabase
        .from('vehicle_sizes')
        .select('*')
        .eq('is_active', true)
        .order('price_multiplier')

      if (sizesError) return { data: null, error: sizesError }

      const minMultiplier = vehicleSizes[0]?.price_multiplier || 1
      const maxMultiplier = vehicleSizes[vehicleSizes.length - 1]?.price_multiplier || 1

      const serviceWithPricing: ServiceWithPricing = {
        ...service,
        priceRange: {
          min: Math.round(service.base_price * minMultiplier),
          max: Math.round(service.base_price * maxMultiplier),
        },
      }

      return { data: serviceWithPricing, error: null }
    }, 'Failed to fetch service')
  }

  async getServiceCategories(): Promise<ServiceResponse<ServiceCategory[]>> {
    return this.executeQuery(async () => {
      return this.supabase
        .from('service_categories')
        .select('*')
        .eq('is_active', true)
        .order('display_order')
    }, 'Failed to fetch service categories')
  }

  async getVehicleSizes(): Promise<ServiceResponse<VehicleSize[]>> {
    return this.executeQuery(async () => {
      return this.supabase
        .from('vehicle_sizes')
        .select('*')
        .eq('is_active', true)
        .order('display_order')
    }, 'Failed to fetch vehicle sizes')
  }

  async createService(serviceData: Partial<Service>): Promise<ServiceResponse<Service>> {
    return this.executeQuery(async () => {
      return this.supabase
        .from('services')
        .insert(serviceData)
        .select()
        .single()
    }, 'Failed to create service')
  }

  async updateService(id: string, serviceData: Partial<Service>): Promise<ServiceResponse<Service>> {
    return this.executeQuery(async () => {
      return this.supabase
        .from('services')
        .update(serviceData)
        .eq('id', id)
        .select()
        .single()
    }, 'Failed to update service')
  }

  async deleteService(id: string): Promise<ServiceResponse<void>> {
    return this.executeQuery(async () => {
      return this.supabase
        .from('services')
        .update({ is_active: false })
        .eq('id', id)
    }, 'Failed to delete service')
  }
}
```

### 3.3 Pricing Service

**Create: `src/lib/services/pricing.ts`**

```typescript
import { BaseService } from './base'
import { VehicleSize, Service } from '@/lib/utils/database'

export interface PricingCalculation {
  basePrice: number
  vehicleSizeMultiplier: number
  distanceSurcharge: number
  totalPrice: number
  breakdown: {
    servicePrice: number
    vehicleSizeAdjustment: number
    distanceFee: number
  }
}

export interface PricingInput {
  serviceId: string
  vehicleSizeId: string
  distanceFromBase?: number
}

export class PricingService extends BaseService {
  
  private readonly FREE_RADIUS_MILES = 10
  private readonly SURCHARGE_PER_MILE = 2.50
  private readonly MAX_SERVICE_RADIUS = 17.5

  async calculatePrice(input: PricingInput): Promise<ServiceResponse<PricingCalculation>> {
    return this.executeQuery(async () => {
      // Get service information
      const { data: service, error: serviceError } = await this.supabase
        .from('services')
        .select('id, name, base_price')
        .eq('id', input.serviceId)
        .eq('is_active', true)
        .single()

      if (serviceError) return { data: null, error: serviceError }

      // Get vehicle size information
      const { data: vehicleSize, error: sizeError } = await this.supabase
        .from('vehicle_sizes')
        .select('id, name, price_multiplier')
        .eq('id', input.vehicleSizeId)
        .eq('is_active', true)
        .single()

      if (sizeError) return { data: null, error: sizeError }

      // Calculate pricing
      const basePrice = service.base_price
      const vehicleSizeMultiplier = vehicleSize.price_multiplier
      const servicePrice = basePrice * vehicleSizeMultiplier

      // Calculate distance surcharge
      const distance = input.distanceFromBase || 0
      let distanceSurcharge = 0

      if (distance > this.MAX_SERVICE_RADIUS) {
        return { 
          data: null, 
          error: { 
            message: `Service area limited to ${this.MAX_SERVICE_RADIUS} miles`,
            code: 'OUTSIDE_SERVICE_AREA'
          }
        }
      }

      if (distance > this.FREE_RADIUS_MILES) {
        const chargeableMiles = distance - this.FREE_RADIUS_MILES
        distanceSurcharge = chargeableMiles * this.SURCHARGE_PER_MILE
      }

      const totalPrice = servicePrice + distanceSurcharge

      const calculation: PricingCalculation = {
        basePrice,
        vehicleSizeMultiplier,
        distanceSurcharge,
        totalPrice: Math.round(totalPrice * 100) / 100, // Round to 2 decimal places
        breakdown: {
          servicePrice: Math.round(servicePrice * 100) / 100,
          vehicleSizeAdjustment: Math.round((servicePrice - basePrice) * 100) / 100,
          distanceFee: Math.round(distanceSurcharge * 100) / 100,
        },
      }

      return { data: calculation, error: null }
    }, 'Failed to calculate pricing')
  }

  async getPricingMatrix(): Promise<ServiceResponse<{
    services: Service[]
    vehicleSizes: VehicleSize[]
    pricingRules: {
      freeRadiusMiles: number
      surchargePerMile: number
      maxServiceRadius: number
    }
  }>> {
    return this.executeQuery(async () => {
      // Get all active services
      const { data: services, error: servicesError } = await this.supabase
        .from('services')
        .select('*')
        .eq('is_active', true)
        .order('display_order')

      if (servicesError) return { data: null, error: servicesError }

      // Get all vehicle sizes
      const { data: vehicleSizes, error: sizesError } = await this.supabase
        .from('vehicle_sizes')
        .select('*')
        .eq('is_active', true)
        .order('display_order')

      if (sizesError) return { data: null, error: sizesError }

      return {
        data: {
          services,
          vehicleSizes,
          pricingRules: {
            freeRadiusMiles: this.FREE_RADIUS_MILES,
            surchargePerMile: this.SURCHARGE_PER_MILE,
            maxServiceRadius: this.MAX_SERVICE_RADIUS,
          },
        },
        error: null,
      }
    }, 'Failed to fetch pricing matrix')
  }

  async validateServiceArea(distanceFromBase: number): Promise<ServiceResponse<{
    isWithinArea: boolean
    distanceSurcharge: number
    message: string
  }>> {
    try {
      if (distanceFromBase > this.MAX_SERVICE_RADIUS) {
        return this.handleSuccess({
          isWithinArea: false,
          distanceSurcharge: 0,
          message: `Location is outside our ${this.MAX_SERVICE_RADIUS}-mile service area`,
        })
      }

      let distanceSurcharge = 0
      let message = 'Location is within our service area'

      if (distanceFromBase > this.FREE_RADIUS_MILES) {
        const chargeableMiles = distanceFromBase - this.FREE_RADIUS_MILES
        distanceSurcharge = chargeableMiles * this.SURCHARGE_PER_MILE
        message = `Location includes ¬£${distanceSurcharge.toFixed(2)} travel surcharge`
      }

      return this.handleSuccess({
        isWithinArea: true,
        distanceSurcharge: Math.round(distanceSurcharge * 100) / 100,
        message,
      })
    } catch (error) {
      return this.handleError('Failed to validate service area', 'VALIDATION_ERROR', error)
    }
  }
}
```

---

## STEP 4: SERVICES API ENDPOINTS (45 minutes)

### 4.1 Services API Routes

**Create: `src/app/api/services/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { ApiValidator } from '@/lib/api/validation'
import { ServicesService } from '@/lib/services/services'
import { z } from 'zod'

const serviceQuerySchema = z.object({
  category_id: z.string().uuid().optional(),
  search: z.string().optional(),
  active: z.string().optional().transform(val => val === 'true'),
})

export async function GET(request: NextRequest) {
  try {
    // Validate query parameters
    const { data: query, error: validationError } = ApiValidator.validateQuery(
      request,
      serviceQuerySchema
    )

    if (validationError) {
      return validationError
    }

    const servicesService = new ServicesService()
    
    const result = await servicesService.getAllServices({
      categoryId: query.category_id,
      search: query.search,
      isActive: query.active,
    })

    if (!result.success) {
      return ApiResponseHandler.error(
        result.error!.message,
        result.error!.code,
        500
      )
    }

    return ApiResponseHandler.success(result.data)

  } catch (error) {
    console.error('Services API error:', error)
    return ApiResponseHandler.serverError('Failed to fetch services')
  }
}
```

**Create: `src/app/api/services/[id]/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { ApiValidator } from '@/lib/api/validation'
import { ServicesService } from '@/lib/services/services'
import { z } from 'zod'

const paramsSchema = z.object({
  id: z.string().uuid('Invalid service ID'),
})

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Validate parameters
    const { data: validatedParams, error: validationError } = ApiValidator.validateParams(
      params,
      paramsSchema
    )

    if (validationError) {
      return validationError
    }

    const servicesService = new ServicesService()
    
    const result = await servicesService.getServiceById(validatedParams.id)

    if (!result.success) {
      if (result.error!.code === 'DATABASE_ERROR') {
        return ApiResponseHandler.notFound('Service not found')
      }
      
      return ApiResponseHandler.error(
        result.error!.message,
        result.error!.code,
        500
      )
    }

    return ApiResponseHandler.success(result.data)

  } catch (error) {
    console.error('Service detail API error:', error)
    return ApiResponseHandler.serverError('Failed to fetch service')
  }
}
```

**Create: `src/app/api/services/categories/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { ServicesService } from '@/lib/services/services'

export async function GET(request: NextRequest) {
  try {
    const servicesService = new ServicesService()
    
    const result = await servicesService.getServiceCategories()

    if (!result.success) {
      return ApiResponseHandler.error(
        result.error!.message,
        result.error!.code,
        500
      )
    }

    return ApiResponseHandler.success(result.data)

  } catch (error) {
    console.error('Service categories API error:', error)
    return ApiResponseHandler.serverError('Failed to fetch service categories')
  }
}
```

**Create: `src/app/api/services/vehicle-sizes/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { ServicesService } from '@/lib/services/services'

export async function GET(request: NextRequest) {
  try {
    const servicesService = new ServicesService()
    
    const result = await servicesService.getVehicleSizes()

    if (!result.success) {
      return ApiResponseHandler.error(
        result.error!.message,
        result.error!.code,
        500
      )
    }

    return ApiResponseHandler.success(result.data)

  } catch (error) {
    console.error('Vehicle sizes API error:', error)
    return ApiResponseHandler.serverError('Failed to fetch vehicle sizes')
  }
}
```

### 4.2 Pricing API Routes

**Create: `src/app/api/pricing/calculate/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { ApiValidator } from '@/lib/api/validation'
import { PricingService } from '@/lib/services/pricing'
import { z } from 'zod'

const pricingSchema = z.object({
  serviceId: z.string().uuid('Invalid service ID'),
  vehicleSizeId: z.string().uuid('Invalid vehicle size ID'),
  distanceFromBase: z.number().min(0).max(50).optional(),
})

export async function POST(request: NextRequest) {
  try {
    // Validate request body
    const { data: body, error: validationError } = await ApiValidator.validateBody(
      request,
      pricingSchema
    )

    if (validationError) {
      return validationError
    }

    const pricingService = new PricingService()
    
    const result = await pricingService.calculatePrice(body)

    if (!result.success) {
      if (result.error!.code === 'OUTSIDE_SERVICE_AREA') {
        return ApiResponseHandler.error(
          result.error!.message,
          'OUTSIDE_SERVICE_AREA',
          422
        )
      }
      
      return ApiResponseHandler.error(
        result.error!.message,
        result.error!.code,
        500
      )
    }

    return ApiResponseHandler.success(result.data)

  } catch (error) {
    console.error('Pricing calculation API error:', error)
    return ApiResponseHandler.serverError('Failed to calculate pricing')
  }
}
```

**Create: `src/app/api/pricing/matrix/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { PricingService } from '@/lib/services/pricing'

export async function GET(request: NextRequest) {
  try {
    const pricingService = new PricingService()
    
    const result = await pricingService.getPricingMatrix()

    if (!result.success) {
      return ApiResponseHandler.error(
        result.error!.message,
        result.error!.code,
        500
      )
    }

    return ApiResponseHandler.success(result.data)

  } catch (error) {
    console.error('Pricing matrix API error:', error)
    return ApiResponseHandler.serverError('Failed to fetch pricing matrix')
  }
}
```

**Create: `src/app/api/pricing/validate-area/route.ts`**

```typescript
import { NextRequest } from 'next/server'
import { ApiResponseHandler } from '@/lib/api/response'
import { ApiValidator } from '@/lib/api/validation'
import { PricingService } from '@/lib/services/pricing'
import { z } from 'zod'

const validateAreaSchema = z.object({
  distanceFromBase: z.number().min(0, 'Distance must be positive').max(100, 'Distance too large'),
})

export async function POST(request: NextRequest) {
  try {
    // Validate request body
    const { data: body, error: validationError } = await ApiValidator.validateBody(
      request,
      validateAreaSchema
    )

    if (validationError) {
      return validationError
    }

    const pricingService = new PricingService()
    
    const result = await pricingService.validateServiceArea(body.distanceFromBase)

    if (!result.success) {
      return ApiResponseHandler.error(
        result.error!.message,
        result.error!.code,
        500
      )
    }

    return ApiResponseHandler.success(result.data)

  } catch (error) {
    console.error('Service area validation API error:', error)
    return ApiResponseHandler.serverError('Failed to validate service area')
  }
}
```

---

## STEP 5: VALIDATION AND TESTING (30 minutes)

### 5.1 Create Admin Users

Run the admin user creation script:

```bash
npm run create-admins
```

**Expected Output:**
```
üöÄ Creating admin users...
‚úÖ Successfully created admin: zell@love4detailing.com
‚úÖ Successfully created super_admin: paul@evans-studio.co.uk

üìä Summary:
‚úÖ Successfully created: 2 users
‚ùå Failed: 0 users

üîê Important Security Notes:
1. Admin users should change their passwords immediately after first login
2. Use strong, unique passwords for all admin accounts
3. Enable MFA if available in your authentication system

üìß Admin Login Credentials:
admin: zell@love4detailing.com / TempPass123!
super_admin: paul@evans-studio.co.uk / DevPass123!

‚ö†Ô∏è  Store these credentials securely and delete them from logs!
```

### 5.2 API Endpoint Testing

**Test Authentication APIs:**

```bash
# Test registration
curl -X POST http://localhost:3000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123",
    "firstName": "Test",
    "lastName": "User"
  }'

# Test login with admin user
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "zell@love4detailing.com",
    "password": "TempPass123!"
  }'
```

**Test Services APIs:**

```bash
# Get all services
curl http://localhost:3000/api/services

# Get service categories
curl http://localhost:3000/api/services/categories

# Get vehicle sizes
curl http://localhost:3000/api/services/vehicle-sizes
```

**Test Pricing APIs:**

```bash
# Get pricing matrix
curl http://localhost:3000/api/pricing/matrix

# Test service area validation
curl -X POST http://localhost:3000/api/pricing/validate-area \
  -H "Content-Type: application/json" \
  -d '{"distanceFromBase": 15}'

# Test pricing calculation (you'll need actual service and vehicle size IDs)
curl -X POST http://localhost:3000/api/pricing/calculate \
  -H "Content-Type: application/json" \
  -d '{
    "serviceId": "uuid-from-services-api",
    "vehicleSizeId": "uuid-from-vehicle-sizes-api",
    "distanceFromBase": 12
  }'
```

### 5.3 API Response Format Validation

**Create: `src/app/api/test-responses/route.ts`** (for validation)

```typescript
import { ApiResponseHandler } from '@/lib/api/response'

export async function GET() {
  // Test all response types to ensure consistency
  const testResponses = {
    success: ApiResponseHandler.success({ message: 'Success test' }),
    error: ApiResponseHandler.error('Test error', 'TEST_ERROR'),
    validation: ApiResponseHandler.validationError('Validation test'),
    unauthorized: ApiResponseHandler.unauthorized(),
    forbidden: ApiResponseHandler.forbidden(),
    notFound: ApiResponseHandler.notFound(),
    serverError: ApiResponseHandler.serverError(),
  }

  return ApiResponseHandler.success({
    message: 'All response formats validated',
    testResponses: Object.keys(testResponses),
  })
}
```

### 5.4 TypeScript Compilation Test

```bash
# Verify no TypeScript errors
npx tsc --noEmit

# Test production build
npm run build
```

### 5.5 Integration Testing

**Create: `src/app/api-test/page.tsx`** (for manual testing)

```typescript
'use client'

import { useState } from 'react'
import { Button } from '@/components/ui/primitives/Button'

export default function ApiTestPage() {
  const [results, setResults] = useState<Record<string, any>>({})
  const [loading, setLoading] = useState<Record<string, boolean>>({})

  const testEndpoint = async (name: string, url: string, options?: RequestInit) => {
    setLoading(prev => ({ ...prev, [name]: true }))
    
    try {
      const response = await fetch(url, options)
      const data = await response.json()
      
      setResults(prev => ({
        ...prev,
        [name]: {
          status: response.status,
          success: data.success,
          data: data.data,
          error: data.error,
          timestamp: data.metadata?.timestamp,
        }
      }))
    } catch (error) {
      setResults(prev => ({
        ...prev,
        [name]: {
          status: 'ERROR',
          error: error instanceof Error ? error.message : 'Unknown error'
        }
      }))
    } finally {
      setLoading(prev => ({ ...prev, [name]: false }))
    }
  }

  const tests = [
    {
      name: 'Services',
      url: '/api/services',
    },
    {
      name: 'Categories',
      url: '/api/services/categories',
    },
    {
      name: 'Vehicle Sizes',
      url: '/api/services/vehicle-sizes',
    },
    {
      name: 'Pricing Matrix',
      url: '/api/pricing/matrix',
    },
    {
      name: 'Health Check',
      url: '/api/health',
    },
  ]

  return (
    <div className="container py-8">
      <h1 className="text-3xl font-bold mb-8">API Testing Dashboard</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-8">
        {tests.map(test => (
          <div key={test.name} className="border rounded-lg p-4">
            <h3 className="font-semibold mb-2">{test.name}</h3>
            <Button
              onClick={() => testEndpoint(test.name, test.url)}
              disabled={loading[test.name]}
              size="sm"
            >
              {loading[test.name] ? 'Testing...' : 'Test API'}
            </Button>
            
            {results[test.name] && (
              <div className="mt-2 text-sm">
                <div className={`inline-block px-2 py-1 rounded text-xs ${
                  results[test.name].success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                }`}>
                  {results[test.name].success ? 'SUCCESS' : 'ERROR'}
                </div>
                <div className="text-gray-600 mt-1">
                  Status: {results[test.name].status}
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
      
      <div className="space-y-4">
        <h2 className="text-xl font-semibold">Test Results</h2>
        <pre className="bg-gray-100 p-4 rounded-lg overflow-auto text-xs">
          {JSON.stringify(results, null, 2)}
        </pre>
      </div>
    </div>
  )
}
```

---

## PHASE 2 SUCCESS CRITERIA CHECKLIST

Before proceeding to Phase 3, verify all the following items:

### ‚úÖ **API Foundation**
- [ ] All API endpoints follow standardized response format
- [ ] API validation working for all endpoints
- [ ] Error handling consistent across all routes
- [ ] TypeScript compilation passes with zero errors

### ‚úÖ **Authentication System**
- [ ] Admin users created successfully (zell and paul)
- [ ] Registration API working
- [ ] Login API working
- [ ] User profile API working
- [ ] Role-based authentication middleware functioning

### ‚úÖ **Services Layer**
- [ ] Services API returning all data correctly
- [ ] Service categories API working
- [ ] Vehicle sizes API working
- [ ] Pricing calculation API working
- [ ] Service area validation working

### ‚úÖ **Database Integration**
- [ ] All services connect to database successfully
- [ ] RLS policies allow proper data access
- [ ] Seed data accessible through APIs
- [ ] No database connection errors

### ‚úÖ **Testing & Validation**
- [ ] All API endpoints return expected data format
- [ ] Manual API tests pass (curl commands)
- [ ] API test page shows all green results
- [ ] Production build completes successfully
- [ ] No console errors in development

---

## COMMON TROUBLESHOOTING

### Issue: Admin User Creation Fails

**Symptoms:**
- Script fails with authentication errors
- Users are created but profiles are missing

**Solutions:**
1. **Check service role key:**
   ```bash
   # Verify in .env.local
   echo $SUPABASE_SERVICE_ROLE_KEY
   ```

2. **Verify RLS policies:**
   ```sql
   -- Temporarily check if RLS is blocking
   SELECT * FROM user_profiles LIMIT 1;
   ```

3. **Check for existing users:**
   ```sql
   -- Delete existing users if testing
   DELETE FROM auth.users WHERE email IN ('zell@love4detailing.com', 'paul@evans-studio.co.uk');
   ```

### Issue: API Endpoints Return 500 Errors

**Symptoms:**
- APIs work locally but fail in testing
- Database connection errors

**Solutions:**
1. **Check environment variables:**
   ```typescript
   // Add to api/health/route.ts
   console.log('Supabase URL:', process.env.NEXT_PUBLIC_SUPABASE_URL)
   console.log('Has service key:', !!process.env.SUPABASE_SERVICE_ROLE_KEY)
   ```

2. **Verify database schema:**
   ```sql
   -- Check if tables exist
   SELECT table_name FROM information_schema.tables 
   WHERE table_schema = 'public';
   ```

### Issue: TypeScript Compilation Errors

**Symptoms:**
- `npx tsc --noEmit` shows errors
- Build fails with type issues

**Solutions:**
1. **Check import paths:**
   ```typescript
   // Ensure all imports use proper paths
   import { createClient } from '@/lib/supabase/server'
   ```

2. **Verify database types:**
   ```bash
   # Regenerate if needed
   supabase gen types typescript --project-id YOUR_PROJECT_ID > src/lib/supabase/types.ts
   ```

---

## DEPLOYMENT PREPARATION

### Update Environment Variables

Add these to your `.env.local` and Vercel environment:

```bash
# Add these for Phase 2
RESEND_API_KEY=your_actual_resend_key
NEXT_PUBLIC_APP_NAME=Love4Detailing
NEXT_PUBLIC_SUPPORT_EMAIL=support@love4detailing.com
```

### Vercel Deployment Test

```bash
# Test build for Vercel compatibility
npm run build

# Check for any build warnings
cat .next/build-manifest.json | grep -i error
```

---

## PHASE 2 COMPLETION VALIDATION

### Final Checklist

1. **Admin Users Test:**
   ```bash
   npm run create-admins
   # Should show success for both users
   ```

2. **API Endpoints Test:**
   ```bash
   curl http://localhost:3000/api/services
   curl http://localhost:3000/api/pricing/matrix
   # Both should return {"success": true, ...}
   ```

3. **Authentication Test:**
   ```bash
   # Login should work with admin credentials
   curl -X POST http://localhost:3000/api/auth/login \
     -H "Content-Type: application/json" \
     -d '{"email": "zell@love4detailing.com", "password": "TempPass123!"}'
   ```

4. **TypeScript & Build Test:**
   ```bash
   npx tsc --noEmit && npm run build
   # Should complete with no errors
   ```

### Success Metrics

**Phase 2 is complete when:**
- ‚úÖ All API endpoints return standardized responses
- ‚úÖ Admin users are created and can authenticate
- ‚úÖ Services and pricing APIs return real data
- ‚úÖ TypeScript compiles without errors
- ‚úÖ Production build succeeds
- ‚úÖ API test page shows all green results

**Ready for Phase 3 when:**
- All authentication flows work
- All service data is accessible via APIs
- Pricing calculations work correctly
- No database connection issues
- Build system is stable

---

## NEXT STEPS

Phase 3 will implement:
- **Multi-step booking flow** with vehicle/pricing integration
- **Customer dashboard** with booking management
- **Time slot management** system
- **Email notification** service
- **Customer address and vehicle management**

The API foundation you've built in Phase 2 provides the reliable backend that Phase 3's user-facing features will depend on.

**Estimated Phase 2 Completion Time:** 6-8 hours following this guide systematically.

**Critical Success Factor:** All API endpoints must work reliably before Phase 3. The booking system depends entirely on the services and pricing APIs you've just implemented.